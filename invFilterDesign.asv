clear all;
close all;

fileNames = {
%'CutOf_iPhone_5S_MFRecorder_2017-04-27 17-08-07_SweepOnly_h_bSpectr'
%'CutOf_Samsung Galaxy Ace 20170427_173930_SweepOnly_h_bSpectr'
'CutOf_Samsung Galaxy Alpha - 20170427_183001_SweepOnly_h_bSpectr'
%'CutOf_Samsung Galaxy Mini 2 - 20170427_174623_SweepOnly_h_bSpectr'
};

startFreq = 100;
endFreq = 10000;
div = 9900/65535;

load('A_weight.mat');
load('tolerance.mat');

for fileNum = 1:length(fileNames)
    load([fileNames{fileNum}]);
    
    % -------------------------------------------------------------------
    % Ezzel tetszõleges felbontásra ki tudod számolni a frekvenciamenetet
    f_interp = logspace(log10(startFreq),log10(endFreq),10000);
    f_interp_plot = logspace(log10(startFreq),log10(endFreq),600);
    X_interp = interp1(phone_bFreqs, phone_bX, f_interp, 'pchip');
    X_interp_plot = interp1(phone_bFreqs, phone_bX, f_interp_plot, 'pchip');
    % -------------------------------------------------------------------
    
    % A_wight, tolerance kiszámolása f_intrep helyeken (csak egyszer számoljuk ki)
    if(fileNum == 1)
        A_interp = interp1(A_weight(:,1), A_weight(:,2) , f_interp, 'pchip');
        tol_interp = interp1(tolerance(:,1), tolerance(:,2:3) , f_interp, 'pchip');
        tol_interp_plot = interp1(tolerance(:,1), tolerance(:,2:3) , f_interp_plot, 'pchip');
    end
   
    % H_mic to dB scale
    H_mic = 20*log10(X_interp);
    % H_mic * A_weight
    H_mic = H_mic + A_interp;
   
    % find 1kHz
    trgt_f = find(f_interp(1:end-1)<1000 & f_interp(2:end)>1000)
    % H_mic offset with Magnitude[dB] at 1kHz 
    H_mic = H_mic - H_mic(trgt_f) ;
    % H_mic számolása megjelenítéshez
    H_mic_plot = interp1(f_interp, H_mic, f_interp_plot, 'pchip');

    H_trgt = zeros(length(f_interp),1);
    H_trgt_plot = zeros(length(f_interp_plot),1);
    figure(fileNum)
    semilogx(f_interp_plot,H_mic_plot)%r
    title(fileNames{fileNum},'Interpreter', 'none')
    xlabel('Frequency (Hz)')
    ylabel('Magnitude (dB)')
    hold on
    semilogx(f_interp_plot,H_trgt_plot)%b
    semilogx(f_interp_plot,tol_interp_plot(:,1:2),'r--')
    leg = {'H_{mic}original';'H_{trgt}';'tolerance band';'';'1';'2';'3';'4';'5';'6'};
    legend(leg(1:3))
    %set(gca, 'XScale', 'log')
   
    %hold off;
    %pause
    
    for filterNum = 1:6
    
        % H_mic and H_trgt=0 crossings
        cross = find((H_mic(1:end-1)>0 & H_mic(2:end) < 0) | (H_mic(1:end-1)<0 & H_mic(2:end)>0));
        areaNum = length(cross)+1;

        % start-end frequency
        startEndFreq = [startFreq f_interp(cross) endFreq];
        startEnd = [1 cross length(f_interp)];

        % error areas
        errorAreas = zeros(areaNum,1);
        error = H_mic' - H_trgt;
        for i = 1:areaNum
            errorAreas(i) = sum(abs(error(startEnd(i):startEnd(i+1))));
        end
         
        

        % maximum errors
        maxErrors = zeros(areaNum,1);
        maxErrorsFreq = zeros(areaNum,1);
        maxErrorsPlace = zeros(areaNum,1);
        for i = 1:areaNum
            maxFlag = 0;
            if (H_mic(startEnd(i)+1) > 0)
                [maxErrors(i), maxErrorsPlace(i)] = max(H_mic(startEnd(i):startEnd(i+1)));
                maxFlag = 1;
            else
                [maxErrors(i), maxErrorsPlace(i)] = min(H_mic(startEnd(i):startEnd(i+1)));
            end
            maxErrorsPlace(i) = maxErrorsPlace(i) + startEnd(i)-1;
            maxErrorsFreq(i) =  f_interp(maxErrorsPlace(i));
            % if a maximum error of an error area is inside the tolerance
            % band, error area will be 0 (it's good enough)
            if(maxFlag == 1)
                if(H_mic(maxErrorsPlace(i)) < tol_interp(maxErrorsPlace(i),1))
                    errorAreas(i) = 0;
                end
            else
                if(H_mic(maxErrorsPlace(i)) > tol_interp(maxErrorsPlace(i),2))
                    errorAreas(i) = 0;
                end
            end
        end
        
        if(max(errorAreas) == 0)
            disp('Class1-es tolerancia sávba tartozó átvitelhez szükséges szûrõk száma: ')
            disp(filterNum-1)
            pause
        end

        % select maximum error area
        [maxArea, maxAreaNum] = max(errorAreas);
        % initial center frequnecy: frequency of the maxumim magnitude in
        % the selected area
        fc=maxErrorsFreq(maxAreaNum);
        % initial bandwidth in octave: bandwidth of the selected area
        bw=log2(startEndFreq(maxAreaNum+1)/startEndFreq(maxAreaNum));
        % initial gain: (-1)*maximum magnitude in the selected area
        gain = (-1)*maxErrors(maxAreaNum);
        fs=44100;
        
        disp('Start End Freq:')
        disp(startEndFreq(maxAreaNum))
        disp(startEndFreq(maxAreaNum+1))
        disp('Kezdeti értékek: ')
        disp ('fc: ')
        disp(fc)
        disp ('bw: ')
        disp(bw)
        disp ('gain: ')
        disp(gain)
        %pause
        % estimate parametric filter
        [estGain,estFc,estBw,Ho,f] = parametricEQest(gain,fc,bw,fs,H_mic,startEndFreq(maxAreaNum),startEndFreq(maxAreaNum+1),f_interp);
        
        disp('A becslõ értékei: ')
        disp ('estFc: ')
        disp(estFc)
        disp ('estBw: ')
        disp(estBw)
        disp ('estGain: ')
        disp(estGain)
        disp('-------------------------')
        
        % new transfer function = transfer function + parametric filter
        H_mic = H_mic + Ho;
        H_mic_plot = interp1(f_interp, H_mic, f_interp_plot, 'pchip');
        
        color = ['r';'g';'y';'m';'c';'k'];
        semilogx(f_interp_plot, H_mic_plot )%, color(filterNum)
        semilogx(f_interp_plot, H_mic_plot )%, color(filterNum)
        set(gca, 'XScale', 'log')
        legend(leg(1:4+filterNum))
        pause
    end
end